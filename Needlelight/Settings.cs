using Microsoft.Win32;
using Needlelight.Interfaces;
using Needlelight.Models;
using Needlelight.Util;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;
using System.Text.Json;
using System.Text.Json.Serialization;
using Needlelight.Enums;
using Needlelight.Services;
using System.Threading;
using System.Threading.Tasks;

namespace Needlelight
{
  [Serializable]
  public class Settings : ISettings
  {
    private string _managedFolder = string.Empty;

    public Dictionary<string, string> ManagedFolders { get; set; } = new(StringComparer.OrdinalIgnoreCase);

    public string ManagedFolder
    {
      get
      {
        var resolved = GetManagedFolderForGame(Game);
        return string.IsNullOrWhiteSpace(resolved) ? _managedFolder : resolved;
      }
      set
      {
        _managedFolder = value ?? string.Empty;
        if (!string.IsNullOrWhiteSpace(Game) && !string.IsNullOrWhiteSpace(value))
        {
          var key = NormalizeGameKey(Game);
          if (!string.IsNullOrEmpty(key))
            ManagedFolders[key] = value;
        }
      }
    }

    [JsonConverter(typeof(JsonStringEnumConverter))]
    public AutoRemoveUnusedDepsOptions AutoRemoveUnusedDeps { get; set; } = AutoRemoveUnusedDepsOptions.Never;
    public bool WarnBeforeRemovingDependents { get; set; } = true;
    public bool UseCustomModlinks { get; set; }
    public string CustomModlinksUri { get; set; } = string.Empty;
    public bool UseGithubMirror { get; set; }
    public string GithubMirrorFormat { get; set; } = string.Empty;

    [JsonConverter(typeof(JsonStringEnumConverter))]
    public SupportedLanguages? PreferredLanguage { get; set; }
    public bool LowStorageMode { get; set; } = false;
    public string ExtraSpaceTaken
    {
      get
      {
        long size = 0;
        if (Directory.Exists(CacheFolder))
        {
          size += FileUtil.GetAllFilesInDirectory(CacheFolder).Sum(x => x.Length);
        }

        var managed = new DirectoryInfo(ManagedFolder);
        foreach (var dir in managed.EnumerateDirectories())
        {
          if (dir.GetFiles().Any(x => x.Name == PackManager.packInfoFileName))
          {
            size += FileUtil.GetAllFilesInDirectory(dir.FullName).Sum(x => x.Length);
          }
        }

        return $"{size / 1024 / 1024} MB";
      }
    }

    public bool RequiresWorkaroundClient { get; set; }

    /// <summary>
    /// Selected game key. Defaults to Hollow Knight.
    /// </summary>
    public string Game { get; set; } = GameProfiles.HollowKnightKey;

    public GameProfile CurrentProfile => GameProfiles.GetByKey(Game);

    private string NormalizeGameKey(string? key) =>
      string.IsNullOrWhiteSpace(key) ? GameProfiles.HollowKnightKey : key.Trim().ToLowerInvariant();

    private string GetManagedFolderForGame(string? key)
    {
      var normalized = NormalizeGameKey(key);
      if (ManagedFolders.TryGetValue(normalized, out var stored) && !string.IsNullOrWhiteSpace(stored))
        return stored;
      return _managedFolder ?? string.Empty;
    }

    // @formatter:off
    private static ImmutableList<string> BuildStaticPaths(GameProfile profile)
    {
      // Common install roots on Windows
      var candidates = new List<string>
            {
                $"Program Files/Steam/steamapps/common/{profile.Name}",
                $"XboxGames/{profile.Name}/Content",
                $"Program Files (x86)/Steam/steamapps/common/{profile.Name}",
                $"Program Files/GOG Galaxy/Games/{profile.Name}",
                $"Program Files (x86)/GOG Galaxy/Games/{profile.Name}",
                $"Steam/steamapps/common/{profile.Name}",
                $"GOG Galaxy/Games/{profile.Name}"
            };

      return candidates
          .SelectMany(path => DriveInfo.GetDrives().Select(d => Path.Combine(d.Name, path)))
          .ToImmutableList();
    }

    private static ImmutableList<string> BuildUserSuffixPaths(GameProfile profile)
    {
      // Linux defaults and symlinks + macOS Steam default app bundle path
      var name = profile.Name;
      var macBundleGuess = name.Replace(' ', '_').ToLowerInvariant() + ".app";
      var macBundleCanonical = name + ".app";

      var linuxRoots = new[]
      {
        ".local/share/Steam/steamapps/common",
        ".steam/steam/steamapps/common",
        ".steam/root/steamapps/common",
        ".var/app/com.valvesoftware.Steam/data/Steam/steamapps/common"
      };

      var suffixes = new List<string>();

      foreach (var root in linuxRoots)
      {
        suffixes.Add($"{root}/{name}");
      }

      // macOS (Steam default app bundle under common)
      suffixes.Add($"Library/Application Support/Steam/steamapps/common/{name}");
      suffixes.Add($"Library/Application Support/Steam/steamapps/common/{name}/{macBundleCanonical}");
      suffixes.Add($"Library/Application Support/Steam/steamapps/common/{macBundleCanonical}");
      suffixes.Add($"Library/Application Support/Steam/steamapps/common/{name}/{macBundleGuess}");
      suffixes.Add($"Library/Application Support/Steam/steamapps/common/{macBundleGuess}");

      return suffixes.ToImmutableList();
    }
    // @formatter:on

    public static string ConfigFolderPath => Path.Combine
        (
            Environment.GetFolderPath
            (
                Environment.SpecialFolder.ApplicationData,
                Environment.SpecialFolderOption.Create
            ),
            "HKModInstaller"
        );

    private static string ConfigPath => Path.Combine(ConfigFolderPath, "HKInstallerSettings.json");
    public string CacheFolder => Path.Combine(ConfigFolderPath, "HKInstallerCache");

    public string ModsFolder
    {
      get
      {
        if (string.Equals(Game, GameProfiles.SilksongKey, StringComparison.OrdinalIgnoreCase))
        {
          var root = PathUtil.TryGetGameRootFromManagedFolder(ManagedFolder);
          if (!string.IsNullOrWhiteSpace(root))
            return Path.Combine(root, "BepInEx", "plugins");
        }

        return Path.Combine(ManagedFolder, "Mods");
      }
    }

    public string DisabledFolder => Path.Combine(ModsFolder, "Disabled");

    internal Settings(string path)
    {
      ManagedFolder = path;

      var culture = Thread.CurrentThread.CurrentUICulture;
      if (Enum.TryParse(culture.TwoLetterISOLanguageName, out SupportedLanguages preferredLanguage))
        PreferredLanguage = preferredLanguage;
    }

    // Used by serializer.
    public Settings()
    {
      ManagedFolder = string.Empty;
      AutoRemoveUnusedDeps = AutoRemoveUnusedDepsOptions.Never;
      PreferredLanguage = null;
      LowStorageMode = false;
    }

    public static string GetOrCreateDirPath()
    {
      string dirPath = Path.GetDirectoryName(ConfigPath) ?? throw new InvalidOperationException();

      // No-op if path already exists.
      Directory.CreateDirectory(dirPath);

      return dirPath;
    }

    internal static Task<ValidPath?> TryAutoDetect()
    {
      // Resolve profile for path detection: if a config file already exists, prefer its Game value
      var profile = GameProfiles.HollowKnight; // default fallback
      try
      {
        var loaded = Load();
        if (loaded is { })
          profile = loaded.CurrentProfile;
      }
      catch { /* ignore and fallback to HK */ }

      return TryAutoDetect(profile);
    }

    /// <summary>
    /// Attempts to auto-detect a valid Managed folder for the provided game profile, without
    /// consulting on-disk settings. Returns null if nothing is found.
    /// </summary>
    internal static async Task<ValidPath?> TryAutoDetect(GameProfile profile, bool allowCrossProfileFallback = true)
    {
      // Use an internal synchronous detector so we can attempt fallbacks without recursion.
      ValidPath? TryDetectInternal(GameProfile p)
      {
        ValidPath? v = null;

        // Try static paths first
        var staticPaths = BuildStaticPaths(p);
        v = staticPaths.Select(sp => PathUtil.ValidateWithSuffixForProfile(sp, p)).FirstOrDefault(x => x is not null);
        if (v is not null) return v;

        // Otherwise, user profile suffixes
        string home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        var userSuffixes = BuildUserSuffixPaths(p);
        v = userSuffixes
             .Select(suffix => Path.Combine(home, suffix))
             .Select(pth => PathUtil.ValidateWithSuffixForProfile(pth, p))
             .FirstOrDefault(x => x is not null);
        if (v is not null) return v;

        if (TryDetectFromRegistry(out var regPath, p))
          return regPath;

        return null;
      }

      // Attempt detection for the requested profile first.
      var path = TryDetectInternal(profile);
      if (path is not null)
        return path;

      // If we couldn't find the requested profile, attempt reasonable fallbacks (e.g., if looking for Hollow Knight
      // but only Silksong is installed, accept Silksong so the user can still use the mod manager).
      if (allowCrossProfileFallback && profile == GameProfiles.HollowKnight)
      {
        var fallback = TryDetectInternal(GameProfiles.Silksong);
        if (fallback is not null)
          return fallback;
      }

      // since it cant detect from registry assume its because it can't access the registry
      await DisplayErrors.AskForAdminReload("Path was not automatically found from registry.");

      return null; // explicit null if nothing detected
    }

    internal static async Task<(ValidPath? Path, GameProfile? Profile)> TryAutoDetectAnyGame()
    {
      // Prefer Hollow Knight first, then Silksong without cross-fallback to avoid looping.
      var hk = await TryAutoDetect(GameProfiles.HollowKnight);
      if (hk is not null) return (hk, GameProfiles.HollowKnight);

      var ss = await TryAutoDetect(GameProfiles.Silksong, allowCrossProfileFallback: false);
      if (ss is not null) return (ss, GameProfiles.Silksong);

      return (null, null);
    }

    private static bool TryDetectFromRegistry([MaybeNullWhen(false)] out ValidPath path, GameProfile profile)
    {
      path = null;

      if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        return false;

      return TryDetectSteamRegistry(out path, profile) || TryDetectGogRegistry(out path, profile);
    }

    [SupportedOSPlatform(nameof(OSPlatform.Windows))]
    private static bool TryDetectGogRegistry([MaybeNullWhen(false)] out ValidPath path, GameProfile profile)
    {
      path = null;

      // Try known profile GOG ids; fallback to HK default.
      var gogIds = (profile.GogIds != null && profile.GogIds.Count > 0)
        ? profile.GogIds
        : new[] { "1308320804" }; // Hollow Knight GOG id

      foreach (var id in gogIds)
      {
        var val = Registry.GetValue(@$"HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\GOG.com\Games\{id}", "workingDir", null) as string;
        if (string.IsNullOrEmpty(val))
          continue;

        if (PathUtil.ValidateWithSuffixForProfile(val, profile) is ValidPath v)
        {
          path = v;
          return true;
        }
      }
      return false;
    }

    [SupportedOSPlatform(nameof(OSPlatform.Windows))]
    private static bool TryDetectSteamRegistry([MaybeNullWhen(false)] out ValidPath path, GameProfile profile)
    {
      path = null;

      if (Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Valve\Steam", "InstallPath", null) is not string steam_install)
        return false;

      IEnumerable<string> lines;

      try
      {
        lines = File.ReadLines(Path.Combine(steam_install, "steamapps", "libraryfolders.vdf"));
      }
      catch (Exception e) when (
          e is FileNotFoundException
              or UnauthorizedAccessException
              or IOException
              or DirectoryNotFoundException
      )
      {
        return false;
      }

      string? Parse(string line)
      {
        line = line.TrimStart();

        if (!line.StartsWith("\"path\""))
          return null;

        string[] pair = line.Split("\t", 2, StringSplitOptions.RemoveEmptyEntries);

        return pair.Length != 2
            ? null
            : pair[1].Trim('"');
      }

      IEnumerable<string> library_paths = lines.Select(Parse).OfType<string>();

      // If we know SteamAppId, parse appmanifest to locate the install dir
      var appId = profile.SteamAppId; // TODO: Confirm Silksong AppId
      if (!string.IsNullOrWhiteSpace(appId))
      {
        foreach (var lib in library_paths)
        {
          var steamapps = Path.Combine(lib, "steamapps");
          var manifest = Path.Combine(steamapps, $"appmanifest_{appId}.acf");
          try
          {
            if (!File.Exists(manifest)) continue;
            string dirName = TryParseInstallDirFromAcf(manifest);
            if (!string.IsNullOrWhiteSpace(dirName))
            {
              var candidate = Path.Combine(steamapps, "common", dirName);
              var v = PathUtil.ValidateWithSuffixForProfile(candidate, profile);
              if (v is not null) { path = v; return true; }
            }
          }
          catch { /* ignore and continue */ }
        }
      }

      // Fallback: search by folder name
      var folderName = profile.Name; // Default folder name
      path = library_paths
        .Select(library_path => Path.Combine(library_path, "steamapps", "common", folderName))
        .Select(p => PathUtil.ValidateWithSuffixForProfile(p, profile))
        .FirstOrDefault(x => x is not null);

      return path is not null;
    }

    /// <summary>
    /// Minimal ACF parser to extract "installdir" value from an appmanifest file.
    /// </summary>
    private static string TryParseInstallDirFromAcf(string manifestPath)
    {
      // Extremely simple approach: scan lines for key "installdir" and read its value.
      // appmanifest files are vdf-like: "installdir"        "Hollow Knight"
      foreach (var line in File.ReadLines(manifestPath))
      {
        var trimmed = line.TrimStart();
        if (!trimmed.StartsWith("\"installdir\"")) continue;
        var parts = trimmed.Split('\t', StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length < 2) continue;
        var value = parts[1].Trim('"');
        if (!string.IsNullOrWhiteSpace(value)) return value;
      }
      return string.Empty;
    }

    public static Settings? Load()
    {
      if (!File.Exists(ConfigPath))
        return null;

      Debug.WriteLine($"ConfigPath: File @ {ConfigPath} exists.");

      string content = File.ReadAllText(ConfigPath);

      try
      {
        var loaded = JsonSerializer.Deserialize<Settings>(content);
        if (loaded is not null)
        {
          var normalizedGame = loaded.NormalizeGameKey(loaded.Game);
          if (string.IsNullOrWhiteSpace(loaded._managedFolder) &&
              loaded.ManagedFolders.TryGetValue(normalizedGame, out var mapped) &&
              !string.IsNullOrWhiteSpace(mapped))
          {
            loaded._managedFolder = mapped;
          }
          else
          {
            loaded.EnsureCurrentGameFolderMapping();
          }
        }

        return loaded;
      }
      // The JSON is malformed, act as if we don't have settings as a backup
      catch (Exception e) when (e is JsonException or ArgumentNullException)
      {
        return null;
      }
    }

    public static Settings Create(string path)
    {
      // Create from ManagedPath.
      var settings = new Settings(path);

      // Infer Game from the managed path if it appears to belong to a known profile.
      try
      {
        if (!string.IsNullOrWhiteSpace(path))
        {
          var lower = path.ToLowerInvariant();
          if (lower.Contains("silksong") || lower.Contains("hollow knight silksong"))
            settings.Game = GameProfiles.SilksongKey;
          else if (lower.Contains("hollow_knight") || lower.Contains("hollow knight"))
            settings.Game = GameProfiles.HollowKnightKey;
        }
      }
      catch { /* best effort only */ }

      settings.Save();

      return settings;
    }

    private void EnsureCurrentGameFolderMapping()
    {
      if (string.IsNullOrWhiteSpace(Game) || string.IsNullOrWhiteSpace(_managedFolder))
        return;

      var key = NormalizeGameKey(Game);
      if (string.IsNullOrWhiteSpace(key)) return;

      if (!ManagedFolders.TryGetValue(key, out var existing) || string.IsNullOrWhiteSpace(existing))
        ManagedFolders[key] = _managedFolder;
    }

    public void Save()
    {
      EnsureCurrentGameFolderMapping();

      string content = JsonSerializer.Serialize(this, new JsonSerializerOptions()
      {
        WriteIndented = true,
      });

      GetOrCreateDirPath();

      string path = ConfigPath;

      File.WriteAllText(path, content);
    }
  }
}
